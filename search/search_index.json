{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":""},{"location":"#overview","title":"Overview","text":"<p>Breeze is and flexible and external Asset Manager. It focuses on 3D Animation and open source software.</p> <p>It is currently being built with Blender in mind. Later it will be extended to more software such as Krita, Guerilla Render, etc.</p> <ul> <li> <p> Flexible</p> <p>Rules and templates are easy to bypass whenever needed.</p> </li> <li> <p> External</p> <p>Files and software are managed from outside, so that multiple software can be used in combination.</p> </li> </ul>"},{"location":"how_to/","title":"How-to","text":""},{"location":"how_to/#how-to","title":"How-to","text":""},{"location":"how_to/#select-and-open-a-version","title":"Select and open a Version","text":"<p>Navigate in the browser to select an Asset, a Stage and a Version.</p> <p>Double-click on the version to open it.</p> <p> </p>"},{"location":"how_to/#create-assets","title":"Create Assets","text":"<p>In <code>Browser &gt; Stage Panel &gt; Asset Selector</code>, click the <code>new</code> button in one of the dropdown menus:</p> <ul> <li>category: adds an empty category to the project </li> <li>name: creates an asset in the selected category, with the default variant <code>-</code></li> <li>variant: creates a new variant for the asset with the selected category and name</li> </ul> <p>Tip</p> <p>To create multiple Assets at once, check <code>Don't Close</code> in the popup</p>"},{"location":"how_to/#assign-users-and-status-to-a-stage","title":"Assign Users and Status to a Stage","text":"<p>Click the <code>User</code> or <code>Status</code> icon to open an Edit Popup. Left-click to confirm, or right-click to cancel.</p> <p> </p>"},{"location":"how_to/#cast-ingredients-in-a-stage","title":"Cast ingredients in a Stage","text":"<p>Clik the <code>plus</code> button under an ingredient slot, and select a Component to cast.</p> <p>Ingredient filters</p> <p>Ingredients are pre-filtered for a given slot. Example: in a rigging Stage, the slot <code>geo</code> only receives geo components. The <code>extra</code> slot can receive any ingredient from the project</p> <p>Edit an existing ingredient</p> <ul> <li>click on it to replace it</li> <li>click on its version number to cast another version from the same Component</li> </ul>"},{"location":"how_to/#build-and-export-a-scene","title":"Build and export a scene","text":"<p>Select a Version and click the Gear icon in the toolbar.</p> <p>From the <code>Turbine Launcher</code>, you can select another context or modify inputs for the upcoming Process.</p> <p>When it is over, go to the <code>Turbine Tab</code> to see a list of your recent processes, with detailed steps, logs, successes and errors. </p>"},{"location":"roadmap/","title":"Roadmap","text":""},{"location":"roadmap/#roadmap","title":"Roadmap","text":""},{"location":"roadmap/#priority","title":"Priority","text":"<ul> <li>remove Software field from versions, find it using the component's extension with: Component.get_software() -&gt; Optional[Software]</li> <li> <p>FIX: rmb in Users List does not cancel it</p> </li> <li> <p>Turbine:</p> <ul> <li>modeling build: version num + dont overwrite to build over an existing version</li> <li> <p>export modeling: use version num input</p> </li> <li> <p>Create processes to be able to do: modeling -&gt; rigging -&gt; shot</p> </li> <li>rigging: build from geo and extra ingredients</li> </ul> </li> <li> <p>better ExportsTable:</p> <ul> <li>mvd</li> <li>context menu</li> </ul> </li> <li> <p>ComponentBrowser: remove work components (wait for more exports, for debug purposes)</p> </li> </ul>"},{"location":"roadmap/#missing-features","title":"Missing features","text":"<ul> <li> <p>Recipes:</p> <ul> <li>toolbar buttons: refresh, autofill, copy, paste, ingredient groups</li> </ul> </li> <li> <p>Turbine:</p> <ul> <li>Jobs list filters</li> <li>relaunch a process from the jobs list</li> </ul> </li> <li> <p>Users:</p> <ul> <li>per project information<ul> <li>roles (sup / lead / graphist / pipe)</li> <li>favorite_assets</li> <li>recent_assets    --&gt; probably a Contributor/Member/PrUser/SubUser document in project_documents, with source_user and the needed extra fields   it is a user with extra project-related fields   can be found with BreezeApp.sub_user</li> </ul> </li> </ul> </li> <li> <p>switch User and Projects</p> <ul> <li>ui to create them</li> </ul> </li> <li> <p>Admin tab: Guis to create and manage db items</p> <ul> <li>Users (for the current project): add users to project / assign roles</li> <li>Stage Templates<ul> <li>process assignment</li> <li>create, delete, icon, color, label, category_filters, assigned_users, etc</li> </ul> </li> </ul> </li> <li> <p>Asset groups</p> </li> <li> <p>Asset data / properties</p> </li> <li> <p>User roles and permissions</p> </li> </ul>"},{"location":"roadmap/#cleans-refactors","title":"Cleans &amp; Refactors","text":"<ul> <li> <p>popups:</p> <ul> <li>transform every popup into browsers with a toolbar style</li> </ul> </li> <li> <p>rework subwidgets hierarchy, move them under Gui/..., utils can probably be removed entirely:</p> <ul> <li>chronometer to Api/utils</li> <li>external toolbar</li> <li>searchbar</li> <li>groups all icon stuff in a single file</li> </ul> </li> <li> <p>mvd: confo and simplify from new knowledge, update stages' mouse events using component tree's code</p> </li> <li> <p>SoftwareClasses: sub-classes for in/out, file management, etc.</p> </li> </ul>"},{"location":"roadmap/#qol-upgrades-to-existing-and-working-features","title":"Qol &amp; Upgrades to existing and working features","text":"<ul> <li> <p>work versions panel: disable when no stages are selected (or a version cannot be created)</p> </li> <li> <p>process_launcher:</p> <ul> <li>cache, remember selected processes and inputs for each context: stage: process ; process: inputs</li> <li>preset the input's height and use scroll area to have a fixed size window</li> </ul> </li> <li> <p>Turbine:</p> <ul> <li>refresh jobs on tab shown</li> <li>show processes and steps duration</li> <li>relaunch from the jobs list</li> </ul> </li> <li> <p>copy/paste users and statuses with ctrl+C/ctrl+V</p> </li> <li> <p>StageTemplateList assignment:</p> <ul> <li>warn if a used stage template is about to be deleted</li> <li>ui to omit or keep them</li> <li>gui to edit recipes</li> </ul> </li> <li> <p>save the gui's state between instances</p> </li> <li> <p>add error messages to steps in step viewer's tree</p> </li> <li> <p>Stage Templates: status and users history</p> </li> <li> <p>Asset browser:</p> <ul> <li>favorites / recent</li> </ul> </li> <li> <p>Ingredient Slots: components history</p> </li> </ul>"},{"location":"features/","title":"Features","text":""},{"location":"features/#features","title":"Features","text":"<p>Breeze is made of multiple contexts. A context is accessible from its tab.</p>"},{"location":"features/#browser","title":"Browser","text":"<p>Create and manage files. Link them together and assemble them into a full project.</p>"},{"location":"features/#turbine","title":"Turbine","text":"<p>Engines history, with a clear visibility of sub-steps, successes and errors. Quick access to Components exported from engines.</p>"},{"location":"features/#admin","title":"Admin","text":"<p>(todo)</p> <ul> <li>Create stage templates and recipe</li> <li>Assign processes to stage templates</li> </ul>"},{"location":"features/admin/","title":"Admin (Features)","text":""},{"location":"features/admin/#admin-features-todo","title":"Admin (Features) (TODO)","text":"<p>A global access and manager to settings, template and rules.</p> <ul> <li>Create stage templates and recipes</li> <li>Assign processes to stage templates</li> <li>etc.</li> </ul>"},{"location":"features/browser/","title":"Browser (Features)","text":""},{"location":"features/browser/#browser-features","title":"Browser (Features)","text":"<p>Browser</p>"},{"location":"features/turbine/","title":"Turbine (Features)","text":""},{"location":"features/turbine/#turbine-features","title":"Turbine (Features)","text":""},{"location":"reference/","title":"Reference","text":""},{"location":"reference/#reference","title":"Reference","text":""},{"location":"reference/#assets-structure","title":"Assets structure","text":""},{"location":"reference/#recipes","title":"Recipes","text":""},{"location":"reference/#turbine","title":"Turbine","text":""},{"location":"reference/assets_structure/","title":"Assets structure (Reference)","text":""},{"location":"reference/assets_structure/#assets-structure-reference","title":"Assets Structure (Reference)","text":"<p>This is the base structure of documents used to register files in the database.</p> <p>An Asset contains multiple Stages that represents each step of its creation. Each Stage generates multiple Components, they become the ingredients of other Stages. Each Component contains multiple iterated Versions of a file.</p>"},{"location":"reference/assets_structure/#classes","title":"Classes","text":""},{"location":"reference/assets_structure/#version","title":"<code>Version</code>","text":"<p>An iteration of a file.</p> Source code in <code>Breeze\\Api\\document_models\\project_documents.py</code> <pre><code>class Version(Document):\n    \"\"\"\n    An iteration of a file.\n    \"\"\"\n    longname = StringField(required=True, primary_key=True)\n\n    component: Component = ReferenceField(document_type=Component, required=True)\n    number: int = IntField(required=True)  # -1 is head\n\n    # TODO: remove and replace with Component.get_software() -&gt; Optional[Software], that uses Component.extension\n    software: Software = ReferenceField(document_type=Software, required=True)  # strange to have in exports\n\n    # deduced from upper documents\n    filepath: str = StringField(required=True)\n\n    creation_user: User = ReferenceField(document_type=User, required=True)\n    last_user: User = ReferenceField(document_type=User, required=True)\n\n    # user editable\n    comment: str = StringField(default=\"\")\n\n    creation_time = DateTimeField(default=datetime.now)\n    timestamp = DateTimeField(default=datetime.now)\n    destinations: list[Stage] = SortedListField(ReferenceField(document_type=Stage, default=[]))\n\n    # todo_list = ReferenceField(document_type='Task', default=[])\n    # thumbnail_path = StringField()\n\n    meta = {\n        'collection': 'Versions',\n        'db_alias': 'current_project',\n    }\n\n    def __repr__(self):\n        return f\"&lt;Version&gt;: {self.longname}\"\n\n    def __str__(self):\n        return self.__repr__()\n\n    @classmethod\n    def create(cls, component: Component, number: int, software: Software, **kwargs):\n        longname = f\"{component.longname}_{number:03d}\"\n        existing_version = Version.objects(longname=longname)\n        if existing_version:\n            raise InvalidDocumentError(f\"Version already exists: {existing_version[0]}\")\n\n        creation_user = BreezeApp.user\n        last_user = creation_user\n\n        # get filepath\n        root = BreezeApp.project.root_path\n        filename = f\"{longname}.{component.extension}\"\n        filepath = Path(root).joinpath(*component.to_folders()).joinpath(filename)\n\n        # create dirs\n        Path(filepath).parent.mkdir(parents=True, exist_ok=True)\n\n        # create document\n        kwargs = dict(longname=longname, component=component, number=number, software=software,\n                      creation_user=creation_user, last_user=last_user, filepath=str(filepath),\n                      **kwargs)\n        kwargs = {k: v for k, v in kwargs.items() if v is not None}\n        version = cls(**kwargs)\n        version.save()\n\n        # add to component\n        component.add_version(version)\n\n        print(f\"Created: {version}\")\n        return version\n\n    def set_comment(self, text: str):\n        old_comment = self.comment\n        self.update(comment=text)\n        print(f\"{self}'s comment changed from '{old_comment}' to '{text}'\")\n\n    def increment(self, comment: str = \"\") -&gt; Self:\n        print(f\"Incrementing {self} ... \")\n        new_version = self.component.create_last_version(software=self.software)\n        new_version.update(comment=comment)\n        return new_version\n\n    def open_folder(self):\n        print(f\"Opening in explorer ... '{self.filepath}'\")\n        subprocess.Popen(f'explorer /select,{self.filepath}')\n\n    def copy_longname(self):\n        utils.copy_to_clipboard(text=self.longname)\n\n    def copy_filepath(self):\n        utils.copy_to_clipboard(text=self.filepath)\n\n    def to_file(self) -&gt; AbstractSoftwareFile:\n        # TODO: replace with File.from_version(version: Version)\n        if self.software.label == 'Blender':\n            return BlenderFile(filepath=self.filepath)\n        else:\n            raise NotImplementedError(f\"File instance for: {self.software}\")\n\n    def open_interactive(self)-&gt; AbstractSoftwareFile:\n        file = self.to_file()\n        file.open_interactive()\n        print(f\"Opening an interactive {self.software.label} file: {self.filepath}\")\n        return file\n\n    def open_background(self)-&gt; AbstractSoftwareFile:\n        file = self.to_file()\n        file.open()\n        print(f\"Opening a background {self.software.label} file: {self.filepath}\")\n        return file\n\n    def get_filter_keys(self) -&gt; str:\n        \"\"\" returns a string of keys used with search bars to filter a list of versions \"\"\"\n        # TODO: it does not work with users\n        #  convert date to something that makes sense to write (actual format: 2025-07-13 19:03:53.368000)\n        keys = [\n            f\"{self.number:03d}\",\n            self.creation_user.pseudo,\n            self.creation_user.fullname,\n            self.last_user.pseudo,\n            self.last_user.fullname,\n            self.component.extension or '-',\n            str(self.timestamp),\n        ]\n        result = \" \".join(s for s in keys)\n        return result\n</code></pre>"},{"location":"reference/assets_structure/#component","title":"<code>Component</code>","text":"<p>An independent building component of the project. It contains multiple Versions. It is exported from a Stage and becomes the ingredient of another Stage.</p> <p>Examples: <code>geo</code>, <code>rig</code>, <code>anim</code>, etc...</p> Source code in <code>Breeze\\Api\\document_models\\project_documents.py</code> <pre><code>class Component(Document):\n    \"\"\"\n    An independent building component of the project.\n    It contains multiple Versions.\n    It is exported from a Stage and becomes the ingredient of another Stage.\n\n    Examples: `geo`, `rig`, `anim`, etc...\n    \"\"\"\n    longname: str = StringField(required=True, primary_key=True)  # category_name_variant_stage_component\n\n    name: str = StringField(required=True)\n    label: str = StringField(required=True)\n    stage: Stage = ReferenceField(document_type=Stage, required=True)\n    extension: str = StringField()  # in work components, get extension from version.software.extension instead\n\n    versions: list['Version'] = SortedListField(ReferenceField(document_type='Version'), default=[])\n    recommended_version: 'Version' = ReferenceField(document_type='Version', default=None)\n\n    # TODO: destinations: list[Stage], reciprocal with Stage.components\n\n    meta = {\n        'collection': 'Components',\n        'db_alias': 'current_project',\n    }\n\n    def __repr__(self):\n        return f\"&lt;Component&gt;: {self.longname}\"\n\n    def __str__(self):\n        return self.__repr__()\n\n    @classmethod\n    def create(cls, name: str, label: str, stage: Stage, extension: str, **kwargs):\n        longname = \"_\".join(s for s in [stage.longname, name, extension])\n        kwargs = dict(longname=longname, name=name, label=label, stage=stage, extension=extension, **kwargs)\n        kwargs = {k: v for k, v in kwargs.items() if v is not None}\n\n        existing_component = Component.objects(longname=longname)\n        if existing_component:\n            raise FileExistsError(f\"{existing_component[0]}\")\n\n        component = cls(**kwargs)\n        component.save()\n        print(f\"Created: {component}\")\n\n        return component\n\n    def to_folders(self) -&gt; list[str]:\n        \"\"\" returns a folder's hierarchy based on its fields \"\"\"\n        folders = self.longname.split(\"_\")  # [character, baby, -, modeling, work, blend]\n        del folders[-1]  # [character, baby, -, modeling, work]\n        folders[-1] = f\"{folders[-1]}_{self.extension}\"  # [character, baby, -, modeling, work_blend]\n        return folders\n\n    def add_version(self, version: 'Version'):\n        if version in self.versions:\n            raise ValueError(f\"{version} is already a version of {self}\")\n        self.versions.append(version)\n        self.save()\n\n    def create_last_version(self, software: Software) -&gt; 'Version':\n        versions: list[Version] = self.versions\n        if not versions:\n            number = 1\n        else:\n            versions = sorted(versions, key=lambda v: v.number, reverse=True)\n            number: int = versions[0].number\n            number += 1\n\n        version = Version.create(component=self, number=number, software=software)\n        return version\n\n    def create_version(self, number: int, software: Software) -&gt; 'Version':\n        version = Version.create(component=self, number=number, software=software)\n        return version\n\n    def get_last_version(self) -&gt; Optional['Version']:\n        versions: list[Version] = self.versions\n        if not versions:\n            return None\n        else:\n            versions = sorted(versions, key=lambda v: v.number, reverse=True)\n            return versions[0]\n\n    def get_version(self, number: int) -&gt; Optional['Version']:\n        versions = [v for v in self.versions if v.number == number]\n        if not versions:\n            return None\n        elif len(versions) &gt; 1:  # this should not be possible\n            raise ValueError(f\"Found more than 1 version with number {number}: {versions}\")\n        else:\n            return versions[0]\n</code></pre>"},{"location":"reference/assets_structure/#stagetemplate","title":"<code>StageTemplate</code>","text":"<p>Model for a Stage, with expected ingredients and associated processes.</p> <p>Examples: <code>modeling</code>, <code>rigging</code>, <code>shading</code>, <code>animation</code>, <code>lighting</code>, etc...</p> Source code in <code>Breeze\\Api\\document_models\\studio_documents.py</code> <pre><code>class StageTemplate(Document):\n    \"\"\"\n    Model for a Stage, with expected ingredients and associated processes.\n\n    Examples: `modeling`, `rigging`, `shading`, `animation`, `lighting`, etc...\n    \"\"\"\n    name: str = StringField(required=True, primary_key=True)\n    label: str = StringField(required=True, unique=True)\n\n    order: int = IntField(default=0)\n    color: str = StringField(default=\"#ffffff\")\n    icon_name: str = StringField(default=\"fa5s.question\")\n\n    # list of available software for this Stage, used to create a new empty Version\n    # TODO: rename to something easier to understand\n    software: list[Software] = SortedListField(ReferenceField(document_type=Software), default=[])\n\n    presets: list[str] = ListField(StringField(), default=[])  # TODO: an api to register presets would be easier to edit without using the ui\n\n    processes: list[Process] = SortedListField(ReferenceField(document_type=Process, default=[]))\n    recipe: dict[str, Any] = DictField()  # dict[name, infos], contains IngredientSlots\n\n    meta = {\n        'collection': 'Stage templates',\n        'db_alias': 'default',\n    }\n\n    def __repr__(self):\n        return f\"&lt;Stage template&gt;: {self.name}\"\n\n    def __str__(self):\n        return self.__repr__()\n\n    # NOTE: GUI does not exist yet\n    @classmethod\n    def create(cls, name: str, label: str, color: str = None, icon_name: str = None, **kwargs) -&gt; Self:\n        kwargs = dict(name=name, label=label, color=color, icon_name=icon_name, **kwargs)\n        kwargs = {k: v for k, v in kwargs.items() if v is not None}\n        stage_template = cls(**kwargs)\n        stage_template.save()\n        print(f\"Created: {stage_template}\")\n        return stage_template\n\n    def add_process(self, process: Process):\n        self.processes.append(process)\n        self.save()\n\n    def set_recipe(self, recipe: dict[str, Any]):\n        self.recipe = recipe\n        self.save()\n        print(f\"{self}'s recipe was set to: {recipe}\")\n\n    def set_ingredient_slot(self, slot_name: str, slot_infos: dict[str, Any], crash_if_exists: bool=True):\n        slot_exists = slot_name in self.recipe.keys()\n\n        if slot_exists and crash_if_exists:\n            raise ValueError(f\"{self}'s recipe already has an ingredient slot with name {slot_name}\")\n        self.recipe[slot_name] = slot_infos\n\n        if slot_exists:\n            print(f\"Ingredient {slot_name} was overridden in {self}'s recipe: from {self.recipe[slot_name]} to {slot_infos}\")\n        else:\n            print(f\"Ingredient {slot_name} was added to {self}'s recipe: {slot_infos}\")\n</code></pre>"},{"location":"reference/assets_structure/#stage","title":"<code>Stage</code>","text":"<p>A step during the creation of an Asset. Uses Components as ingredients, and exports other Components. It always has a <code>work</code> Component that contains work software files.</p> Source code in <code>Breeze\\Api\\document_models\\project_documents.py</code> <pre><code>class Stage(Document):\n    \"\"\"\n    A step during the creation of an Asset.\n    Uses Components as ingredients, and exports other Components.\n    It always has a `work` Component that contains work software files.\n    \"\"\"\n    longname: str = StringField(required=True, primary_key=True)\n    asset: Asset = ReferenceField(document_type=Asset)\n    stage_template: StageTemplate = ReferenceField(document_type=StageTemplate)\n\n    components: list['Component'] = ListField(ReferenceField(document_type='Component'), default=[])\n    work_component: 'Component' = ReferenceField(document_type='Component')\n\n    status: Status = ReferenceField(document_type=Status, default=Status.objects.get(label='WAIT'))\n    # TODO: User unknown, with a question mark icon\n    #  it should appear first in lists, add User.order to have some special users at -1\n    user: User = ReferenceField(document_type=User, default=User.objects.get(pseudo=\"Martin\"))\n\n    ingredients: dict[str, list['Version']] = DictField()  # {name: list[Versions]}\n\n    meta = {\n        'collection': 'Stages',\n        'db_alias': 'current_project',\n    }\n\n    def __repr__(self):\n        return f\"&lt;Stage&gt;: {self.longname}'\"\n\n    def __str__(self):\n        return self.__repr__()\n\n    @classmethod\n    def create(cls, asset: Asset, stage_template: StageTemplate, status: Status=None, **kwargs) -&gt; Self:\n        longname = \"_\".join(s for s in [asset.longname, stage_template.name])\n        kwargs = dict(longname=longname, asset=asset, stage_template=stage_template, status=status, **kwargs)\n        kwargs = {k: v for k, v in kwargs.items() if v is not None}\n        stage = cls(**kwargs)\n        stage.save()\n        print(f\"Created: {stage}\")\n\n        asset.add_stage(stage=stage)\n\n        return stage\n\n    def create_component(self, name: str, label: str, extension: str, crash_if_exists: bool = True) -&gt; 'Component':\n        component = Component.objects(name=name, label=label, extension=extension, stage=self)\n        if len(component) == 1:\n            if crash_if_exists:\n                raise ValueError(f\"{component} is already a component of {self}\")\n            else:\n                return component[0]\n\n        component = Component.create(name=name, label=label, stage=self, extension=extension)\n        self.components.append(component)\n        self.save()\n        return component\n\n    def create_work_component(self, extension: str) -&gt; 'Component':\n        work_component = self.create_component(name=data.Components.work, label=data.Components.work.title(), extension=extension)\n        self.update(work_component=work_component)\n        return work_component\n\n    def add_ingredient(self, name: str, version: 'Version'):\n        if name not in self.ingredients.keys():\n            self.ingredients[name] = []\n        self.ingredients[name].append(version)\n        self.save()\n        self._sort_ingredients()\n        print(f\"{version} was added to the '{name}' ingredients of {self}\")\n\n    def replace_ingredient(self, name: str, old_version: 'Version', new_version: 'Version'):\n        if name not in self.ingredients.keys():\n            raise ValueError(f\"Existing ingredients with name {name} not found in {self}\")\n\n        versions = self.ingredients[name]\n        if old_version not in versions:\n            raise ValueError(f\"Did not find {old_version} in the ingredients {name} of {self}\")\n        versions.remove(old_version)\n        versions.append(new_version)\n\n        self.ingredients[name] = versions\n        self.save()\n        self._sort_ingredients()\n        print(f\"{new_version} replaced {old_version} in the '{name}' ingredients of {self}\")\n\n    def _sort_ingredients(self):\n        sorted_ingredients: dict[str, list[Version]] = {}\n\n        # sort names\n        names = [name for name in self.ingredients.keys()]\n        names.sort()\n        if 'extra' in names:\n            names.remove('extra')\n            names.append('extra')\n\n        # sort versions\n        for name in names:\n            versions = self.ingredients[name]\n            versions = sorted(versions, key=lambda version: (\n                version.component.stage.stage_template.name,\n                version.longname,\n                version.number,\n            ))\n            sorted_ingredients[name] = versions\n\n        # update\n        self.ingredients = sorted_ingredients\n        self.save()\n</code></pre>"},{"location":"reference/assets_structure/#asset","title":"<code>Asset</code>","text":"<p>An element from a project. It is made of a category, a name and variant. For every combination of category + name, there is always a default variant <code>-</code> .</p> <p>Examples: <code>character_Gabin_-</code>, <code>set_Playground_broken</code>, <code>element_tree_B</code>, <code>element_tree_C</code>, <code>sequence_sq0020_sh0180</code>, <code>library_lightrigs_master</code>, <code>sandbox_vfx_boom</code></p> Source code in <code>Breeze\\Api\\document_models\\project_documents.py</code> <pre><code>class Asset(Document):\n    \"\"\"\n    An element from a project. It is made of a category, a name and variant.\n    For every combination of _category + name_, there is always a default variant `-` .\n\n    Examples: `character_Gabin_-`, `set_Playground_broken`, `element_tree_B`, `element_tree_C`,\n    `sequence_sq0020_sh0180`, `library_lightrigs_master`, `sandbox_vfx_boom`\n    \"\"\"\n    longname: str = StringField(required=True, primary_key=True)\n\n    category: str = StringField(required=True)\n    name: str = StringField(required=True)\n    variant: str = StringField(default=\"-\")\n\n    stages: list['Stage'] = ListField(ReferenceField(document_type='Stage'), default=[])\n\n    meta = {\n        'collection': 'Assets',\n        'db_alias': 'current_project'\n    }\n\n    def __repr__(self):\n        return f\"&lt;Asset&gt;: {self.longname}\"\n\n    def __str__(self):\n        return self.__repr__()\n\n    @classmethod\n    def create(cls, category: str, name : str, variant: str = None, **kwargs) -&gt; Self:\n        longname = \"_\".join(s for s in [category, name, variant or \"-\"])\n        kwargs = dict(name=name, category=category, variant=variant, longname=longname, **kwargs)\n        kwargs = {k: v for k, v in kwargs.items() if v is not None}\n        asset = cls(**kwargs)\n        asset.save()\n        print(f\"Created: {asset}\")\n        return asset\n\n    def add_stage(self, stage: 'Stage'):\n        if stage in self.stages:\n            raise ValueError(f\"{stage} is already a stage of {self}\")\n        self.stages.append(stage)\n        self.save()\n\n    def get_stage(self, name: str) -&gt; 'Stage':\n        stage = [stage for stage in self.stages if stage.stage_template.name == name]\n        if not stage:\n            raise ValueError(f\"Stage '{name}' not found in the stages of {self}: {self.stages = }\")\n        return stage[0]\n</code></pre>"},{"location":"reference/assets_structure/#diagram","title":"Diagram","text":"<pre><code>classDiagram\n    direction BT\n\n    Asset --o Stage\n    StageTemplate --o Stage\n    Stage --o Component\n    Component --o Version\n\n    class Asset[\"Asset (Document)\"]{\n        category: str\n        name: str\n        variant: str\n        stages: list[Stage]\n\n        add_stage(stage: Stage)\n        get_stage(name: str) Stage\n    }\n\n    class StageTemplate[\"StageTemplate (Document)\"]{\n        name: str\n        label: str\n        order: int\n        color: str\n        icon_name: str\n\n        presets: list[str]\n        processes: list[Process]\n        recipe: dict[str, Any]\n        software: Software\n    }\n\n    class Stage[\"Stage (Document)\"]{\n        stage_template: StageTemplate\n        asset: Asset\n        components: list[Component]\n        work_component: Component\n        status: Status\n        user: User\n        ingredients: dict[str, list[Version]]\n\n        create_component() Component\n        create_work_component() Component\n        add_ingredient()\n        replace_ingredient()\n        _sort_ingredients()\n    }\n\n    class Component[\"Component (Document)\"]{\n        name: str\n        label: str\n        extension: str\n        stage: Stage\n        versions: list[Version]\n        recommended_version: Version\n\n        add_version()\n        create_version(number: int) Version\n        get_version(number: int) Version\n        create_last_version() Version\n        get_last_version() Optional[Version]\n    }\n\n    class Version[\"Version (Document)\"]{\n        component: Component\n        number: int\n        software: Software\n        filepath: str\n        creation_user: User\n        last_user: User\n        comment: str\n        creation_time: datetime\n        timestamp: datetime\n\n        set_comment()\n        increment() Version\n        to_file() AbstractSoftwareFile\n        open_interactive() AbstractSoftwareFile\n        open_background() AbstractSoftwareFile\n    }</code></pre>"},{"location":"reference/recipes/","title":"Recipes (Reference)","text":""},{"location":"reference/recipes/#recipes-reference","title":"Recipes (Reference)","text":"<p>To use external components in our working files, we use an ingredient-recipes system.</p> <p>We cast expected ingredients in a Stage, based on the recipe (1) from its StageTemplate. These ingredients are the output Components of another Stage.</p> <ol> <li>We can also cast ingredients that are not part of the recipe, if needed.</li> </ol> <p>Example</p> <p>In a <code>rigging</code> stage, we cast a geometry <code>geo</code> from the <code>modeling</code> and a material <code>shd</code> from the <code>shading</code>.</p>"},{"location":"reference/recipes/#classes","title":"Classes","text":""},{"location":"reference/recipes/#recipe","title":"<code>Recipe</code>","text":"<p>List of the IngredientSlots of a StageTemplate.</p> Source code in <code>Breeze\\Api\\recipes\\recipe.py</code> <pre><code>class Recipe:\n    \"\"\"\n    List of the IngredientSlots of a StageTemplate.\n    \"\"\"\n\n    def __init__(self, ingredient_slots: list[IngredientSlot]):\n        self.ingredients_slots = ingredient_slots\n\n    def to_database(self) -&gt; dict[str, Any]:\n        infos: dict[str, Any] = {}\n        for ingredient_slot in self.ingredients_slots:\n            infos[ingredient_slot.name] = ingredient_slot.to_database()\n        return infos\n\n    @classmethod\n    def from_database(cls, infos: dict[str, Any]):\n        ingredient_slots: list[IngredientSlot] = []\n        for slot_name, slot_infos in infos.items():\n            ingredient_slots.append(IngredientSlot.from_database(slot_name=slot_name, slot_infos=slot_infos))\n        return cls(ingredient_slots=ingredient_slots)\n</code></pre>"},{"location":"reference/recipes/#ingredientslot","title":"<code>IngredientSlot</code>","text":"<p>A slot in a Recipe, with associated ComponentFilters. It can receive one or more ingredients.</p> Source code in <code>Breeze\\Api\\recipes\\ingredient_slot.py</code> <pre><code>class IngredientSlot:\n    \"\"\"\n    A slot in a Recipe, with associated ComponentFilters.\n    It can receive one or more ingredients.\n    \"\"\"\n\n    def __init__(self, name: str, multiple: bool = False, filters: list[ComponentFilterBase] = None):\n        self.name = name\n        self.is_multiple = multiple\n        self.filters: list[ComponentFilterBase] = filters or []\n\n        self.allowed_components = self._get_allowed_components()\n\n    def _get_allowed_components(self) -&gt; list[Component]:\n        components: list[Component] = Component.objects\n        for component_filter in self.filters:\n            components = component_filter.get_filtered_components(components=components)\n        return components\n\n    def to_database(self) -&gt; dict[str, Any]:\n        infos: dict[str, Any] = {\n            \"multiple\": self.is_multiple,\n            \"filters\": {},  # dict[name, ComponentFilterBase.to_dict()]\n        }\n        for component_filter in self.filters:\n            infos['filters'][component_filter.name] = component_filter.to_database()\n        return infos\n\n    @classmethod\n    def from_database(cls, slot_name: str, slot_infos: dict[str, Any]):\n        multiple = slot_infos['multiple']\n\n        # get filters\n        filters: list[ComponentFilterBase] = []\n        for filter_name, filter_infos in slot_infos['filters'].items():\n            filters.append(ComponentFilters.from_name(name=filter_name).from_database(infos=filter_infos))\n\n        ingredient_slot = cls(name=slot_name, multiple=multiple, filters=filters)\n        return ingredient_slot\n</code></pre>"},{"location":"reference/recipes/#componentfilterbase","title":"<code>ComponentFilterBase</code>","text":"<p>Defines which Components can or cannot be added to an IngredientSlot, in a Recipe.</p> Source code in <code>Breeze\\Api\\recipes\\component_filters.py</code> <pre><code>class ComponentFilterBase:\n    \"\"\"\n    Defines which Components can or cannot be added to an IngredientSlot, in a Recipe.\n    \"\"\"\n\n    name: str\n\n    def __init__(self, items: list[str], blacklist: bool=False):\n        \"\"\"\n        :param items: list of items to include\n        :param blacklist: if True, parm items becomes a list of items to avoid\n        \"\"\"\n        self.items = [s.lower() for s in items]\n        self.blacklist = blacklist\n\n    def get_filtered_components(self, components: list[Component]) -&gt; list[Component]:\n        input_components = components\n        components = self.filter_components(components=components)\n        if self.blacklist:\n            components = [c for c in input_components if c not in components]\n        return components\n\n    def filter_components(self, components: list[Component]) -&gt; list[Component]:\n        return components\n\n    def to_database(self) -&gt; dict[str, Any]:\n        result = {'items': self.items, 'blacklist': self.blacklist}\n        return result\n\n    @classmethod\n    def from_database(cls, infos: dict[str, Any]):\n        items = infos['items']\n        blacklist = infos['blacklist']\n        return cls(items=items, blacklist=blacklist)\n</code></pre>"},{"location":"reference/recipes/#componentfiltercategorycomponentfilterbase","title":"<code>ComponentFilterCategory(ComponentFilterBase)</code>","text":"<p>Filter components based on their Asset's category.</p> Source code in <code>Breeze\\Api\\recipes\\component_filters.py</code> <pre><code>class ComponentFilterCategory(ComponentFilterBase):\n    \"\"\" Filter components based on their Asset's category. \"\"\"\n    name = 'category'\n    def filter_components(self, components: list[Component]) -&gt; list[Component]:\n        components = [c for c in components if c.stage.asset.category.lower() in self.items]\n        return components\n</code></pre>"},{"location":"reference/recipes/#componentfilterstagecomponentfilterbase","title":"<code>ComponentFilterStage(ComponentFilterBase)</code>","text":"<p>Filter components based on their StageTemplate's name.</p> Source code in <code>Breeze\\Api\\recipes\\component_filters.py</code> <pre><code>class ComponentFilterStage(ComponentFilterBase):\n    \"\"\" Filter components based on their StageTemplate's name. \"\"\"\n    name = 'stage'\n    def filter_components(self, components: list[Component]) -&gt; list[Component]:\n        components = [c for c in components if c.stage.stage_template.name in self.items]\n        return components\n</code></pre>"},{"location":"reference/recipes/#componentfiltercomponentcomponentfilterbase","title":"<code>ComponentFilterComponent(ComponentFilterBase)</code>","text":"<p>Filter components based on their name.</p> Source code in <code>Breeze\\Api\\recipes\\component_filters.py</code> <pre><code>class ComponentFilterComponent(ComponentFilterBase):\n    \"\"\" Filter components based on their name. \"\"\"\n    name = 'component'\n    def filter_components(self, components: list[Component]) -&gt; list[Component]:\n        components = [c for c in components if c.name in self.items]\n        return components\n</code></pre>"},{"location":"reference/recipes/#diagram","title":"Diagram","text":"<pre><code>classDiagram\n    direction BT\n\n    ComponentFilterBase --|&gt; ComponentFilterCategory\n    ComponentFilterBase --|&gt; ComponentFilterStage\n    ComponentFilterBase --|&gt; ComponentFilterComponent\n    ComponentFilterCategory --&gt; ComponentFilters\n    ComponentFilterStage --&gt; ComponentFilters\n    ComponentFilterComponent --&gt; ComponentFilters\n\n    ComponentFilters --&gt; IngredientSlot\n    IngredientSlot --o Recipe\n    Recipe --&gt; StageTemplate\n\n    StageTemplate --* Stage\n    IngredientSlot &lt;..&gt; Version\n    Component --o Version\n    Version --&gt; Stage: Ingredient\n\n    class ComponentFilterBase{\n        items: list[str]\n        blacklist: bool\n\n        get_filtered_components(components: list[Component]) list[Component]\n        filter_components(components: list[Component]) list[Component]\n        to_database() dict[str, Any]\n        @cls from_database(infos: dict[str, Any])\n    }\n\n    class ComponentFilterCategory{\n        name\n        filter_components()\n    }\n    class ComponentFilterStage{\n        name\n        filter_components()\n    }\n    class ComponentFilterComponent{\n        name\n        filter_components()\n    }\n\n    class ComponentFilters {\n        Category: ComponentFilterCategory\n        Stage: ComponentFilterStage\n        Component: ComponentFilterComponent\n        @cls from_name(name: str) Type[ComponentFilterBase]\n    }\n    &lt;&lt;enumeration&gt;&gt; ComponentFilters \n\n    class IngredientSlot {\n        name: str\n        is_multiple: bool\n        filters: list[ComponentFilterBase]\n        allowed_components: list[Components]\n        _get_allowed_components() list[Component]\n        to_database() dict[str, Any]\n        @cls from_database(infos: dict[str, Any])\n    }\n\n    class Recipe {\n        ingredient_slots: list[IngredientSlot]\n        to_database() dict[str, Any]\n        @cls from_database(infos: dict[str, Any])\n    }\n\n    class Stage {\n        stage_template: StageTemplate\n        ingredients: dict[str, list[Version]]\n\n        add_ingredient(name: str, version: Version)\n        replace_ingredient(name: str, old_version: Version, new_version: Version)\n        _sort_ingredients()\n    }\n    class Component {\n    }\n    class Version {\n        component: Component\n    }\n\n    class StageTemplate{\n        recipe: dict[str, Any]\n        set_recipe(recipe: dict[str, Any])\n        set_ingredient_slot(slot_name: str, slot_infos: dict[str, Any], crash_if_exists: bool=True)\n    }\n</code></pre>"},{"location":"reference/turbine/","title":"Turbine (Reference)","text":""},{"location":"reference/turbine/#turbine-reference","title":"Turbine (Reference)","text":"<p>Turbine is used to build, update, export and review scenes. A series of Steps are assembled into an Engine, then they are executed after each other.</p> <p>An Engine is always run from a Version. The existing Engines are stored in its Stage's StageTemplate.</p>"},{"location":"reference/turbine/#relation-with-components","title":"Relation with Components","text":"<p>A Build Engine will use and import the ingredient-Components that are cast in the Version's Stage. An Export Engine will create new out-Components for the Version's Stage.</p>"},{"location":"reference/turbine/#inputs","title":"Inputs","text":"<p>Using the Engine's Gui, a user can define a set of specific inputs before executing the steps.</p> <p>Example</p> <p>Unsetting <code>don't overwrite</code> in an Export Engine will allow existing out-Components to be replaced.</p>"},{"location":"reference/turbine/#classes","title":"Classes","text":""},{"location":"reference/turbine/#turbinestep","title":"<code>TurbineStep</code>","text":"<p>Multiple steps are assembled inside a TurbineEngine and ran after each other.</p> Source code in <code>Breeze\\Api\\turbine\\step.py</code> <pre><code>class TurbineStep(QObject):\n    \"\"\"\n    Multiple steps are assembled inside a TurbineEngine and ran after each other.\n    \"\"\"\n\n    updated = Signal()\n    label: str = \"step_label\"\n    sub_label: str = None\n    tooltip: str = \"step_tooltip\"\n\n    def __init__(self, sub_label: str = None):\n        super().__init__()\n        self.comes_from_dict: bool = False\n        self.sub_label: str = sub_label\n        self.Pill: StepPill = StepPill()\n        self.logger: StepLogger = StepLogger(name=f\"{self.label}__{self.sub_label}__{os.urandom(4)}\")\n\n        self.steps: list[TurbineStep] = []\n\n        self.logger.info(f\"Starting step '{self.label}' ... \")\n        self.log_output = \"\"  # used with Self.from_dict() to recover log\n\n    def set_sub_label(self, sub_label: str):\n        self.sub_label = sub_label\n\n    def get_log(self) -&gt; str:\n        if self.comes_from_dict:\n            return self.log_output\n        else:\n            return self.logger.stream.getvalue()\n\n    @property\n    def pill(self) -&gt; PillModel:\n        return self.Pill.pill\n\n    def add_step(self, step: TypeTurbineStep) -&gt; TypeTurbineStep:\n        self.steps.append(step)\n        step.updated.connect(self.on_sub_step_updated)\n        return step\n\n    def add_group(self, label: str, sub_label: str = None) -&gt; 'StepGroup':\n        step_group = self.add_step(StepGroup(label=label, sub_label=sub_label))\n        return step_group\n\n    def on_sub_step_updated(self):\n        self.updated.emit()\n\n    def run(self, **kwargs):\n        # TODO: duration\n\n        self.Pill.set_running()\n        try:\n            self._inner_run(**kwargs)\n            self.set_success()\n\n        except Exception as e:\n            self.set_failed()\n\n    def _inner_run(self, **kwargs):\n        # override with actions\n        pass\n\n    def set_success(self):\n        self.updated.emit()\n        self.logger.info(msg=f\"... step '{self.label}': SUCCESS \\n\")\n        self.Pill.set_success()\n\n    def set_failed(self):\n        self.logger.error(msg=traceback.format_exc())\n        self.Pill.set_error()\n        self.updated.emit()\n        raise RuntimeError(traceback.format_exc(chain=False))\n\n    # translators\n    def to_dict(self) -&gt; dict[str, any]:\n        return StepTranslator.to_dict(step=self)\n\n    @classmethod\n    def from_dict(cls, infos: dict[str, any]) -&gt; 'TurbineStep':\n        return StepTranslator.from_dict(infos=infos)\n\n    def to_tree_item(self) -&gt; QTreeWidgetItem:\n        return StepTranslator.to_tree_item(step=self)\n</code></pre>"},{"location":"reference/turbine/#turbinegui","title":"<code>TurbineGui</code>","text":"<p>Used to define inputs before running an engine</p> Source code in <code>Breeze\\Gui\\main_windows\\turbine.py</code> <pre><code>class TurbineGui(QMainWindow):\n    \"\"\" Used to define inputs before running an engine \"\"\"\n    def __init__(self):\n        super().__init__()\n        self._init_ui()\n        self._connect_signals()\n\n    def _init_ui(self):\n        select_process_panel = SelectProcessPanel()\n        dock = QDockWidget()\n        dock.setWindowTitle(\"Jobs\")\n        dock.setWidget(select_process_panel)\n        self.addDockWidget(QtCore.Qt.DockWidgetArea.LeftDockWidgetArea, dock)\n        dock.setAllowedAreas(QtCore.Qt.DockWidgetArea.LeftDockWidgetArea)\n\n        steps_viewer_panel = StepsViewer()\n        self.setCentralWidget(steps_viewer_panel)\n\n        logs_panel = StepLogsPanel()\n        dock = QDockWidget()\n        dock.setWindowTitle(\"Logs\")\n        dock.setWidget(logs_panel)\n        self.addDockWidget(QtCore.Qt.DockWidgetArea.BottomDockWidgetArea, dock)\n        dock.setAllowedAreas(QtCore.Qt.DockWidgetArea.BottomDockWidgetArea)\n\n        self.setCorner(QtCore.Qt.Corner.BottomLeftCorner, QtCore.Qt.DockWidgetArea.LeftDockWidgetArea)\n\n        self.select_process_panel = select_process_panel\n        self.steps_viewer_panel = steps_viewer_panel\n        self.logs_panel = logs_panel\n\n    def _connect_signals(self):\n        self.select_process_panel.jobs_list.job_selected.connect(self.on_job_selected)\n        self.steps_viewer_panel.step_selected.connect(self.on_step_selected)\n\n    def on_job_selected(self):\n        job = self.select_process_panel.jobs_list.get_selected_job()\n        self.steps_viewer_panel.populate(job=job)\n\n    def on_step_selected(self):\n        log = self.steps_viewer_panel.selected_step_log\n        print(f\"{log = }\")\n        self.logs_panel.set_log(log=log)\n</code></pre>"},{"location":"reference/turbine/#turbineengine","title":"<code>TurbineEngine</code>","text":"<p>Series of step that from a process. Examples: Build, Export, Review, etc ...</p> Source code in <code>Breeze\\Api\\turbine\\engine.py</code> <pre><code>class TurbineEngine(TurbineStep):\n    \"\"\"\n    Series of step that from a process. Examples: Build, Export, Review, etc ...\n    \"\"\"\n\n    name: str = \"process_name\"\n    label: str = \"process_label\"\n    tooltip: str = \"process_tooltip\"\n    Gui: Type[TurbineGui] = TurbineGui\n\n    @classmethod\n    def from_database(cls, process: Process, context: JobContext) -&gt; Self:\n        \"\"\" Returns the instance of TurbineEngine that matches the given process \"\"\"\n        module_path, class_name = process.class_path.rsplit('.', 1)\n        try:\n            module = importlib.import_module(module_path)\n        except:\n            raise ValueError(f\"module not found from path {module_path}\")\n        ProcessEngine: Type[Self] = getattr(module, class_name)\n        engine = ProcessEngine(context=context)\n        return engine\n\n    @classmethod\n    def get_related_process(cls) -&gt; Process | None:\n        process = Process.objects(longname=cls.name)\n        if process:\n            return process[0]\n        else:\n            return None\n\n    @classmethod\n    def register(cls):\n        \"\"\" Create the Process in the database, or update it if it exists \"\"\"\n        process = cls.get_related_process()\n        if process is None:\n            Process.create(longname=cls.name, class_path=cls.get_class_path(), label=cls.label, tooltip=cls.tooltip)\n        else:\n            process.update(class_path=cls.get_class_path(), label=cls.label, tooltip=cls.tooltip)\n\n    def __init__(self, context: JobContext):\n        super().__init__(sub_label=None)\n        self.context = context\n        self.gui = self.Gui(context=context)\n        self.update_context()\n        self.job: Optional[Job] = None\n\n    def update_context(self):\n        \"\"\" update the Context based on the given inputs \"\"\"\n        inputs = self.gui.inputs\n        if inputs is None:\n            return\n\n        if inputs.use_last_version:\n            version = self.context.component.get_last_version()\n        elif inputs.version_number is not None:\n            version = self.context.component.get_version(number=inputs.version_number)\n        else:\n            version = None\n\n        self.context.set_version(version=version)\n\n    def set_gui(self, gui: TurbineGui):\n        self.gui = gui\n\n    def _add_steps(self):\n        \"\"\" Add steps here rather than during init so that inputs can be updated in-between \"\"\"\n        pass\n\n    def run(self):\n        self._add_steps()\n        self.job = self.create_job()\n        self.Pill.set_idle()\n\n        self.logger.debug(f\"{self.gui.inputs = }\")\n        self.Pill.set_running()\n\n        try:\n            super().run()\n            self.Pill.set_success()\n        except RuntimeError:\n            print(f\"{self.label = }\")\n            print(traceback.format_exc(chain=False))\n            self.Pill.set_error()\n\n        self.update_job()\n\n    def on_sub_step_updated(self):\n        super().on_sub_step_updated()\n        self.update_job()\n    # ------------------------\n    # process\n    # ------------------------\n\n    @classmethod\n    def get_class_path(cls) -&gt; str:\n        path = f\"{cls.__module__}.{cls.__qualname__}\"\n        return str(path)\n\n    # ------------------------\n    # jobs\n    # ------------------------\n    def create_job(self) -&gt; Job:\n        \"\"\" Saves this engine's run as a Job in the db\"\"\"\n        self.register()\n        source_process = Process.objects.get(longname=self.name, label=self.label, tooltip=self.tooltip, class_path=self.get_class_path())\n\n        job = Job.create(source_process=source_process,\n                         steps=self.to_dict(),\n                         inputs=self.gui.to_database(),\n                         user=self.context.user,\n                         version=self.context.version,\n                         creation_time=self.context.creation_time)\n        return job\n\n    def update_job(self):\n        \"\"\" Updates the current job \"\"\"\n        self.job.update(steps=self.to_dict())\n</code></pre>"},{"location":"reference/turbine/#process","title":"<code>Process</code>","text":"<p>The database document that registers an Engine</p> Source code in <code>Breeze\\Api\\document_models\\studio_documents.py</code> <pre><code>class Process(Document):\n    \"\"\"\n    The database document that registers an Engine\n    \"\"\"\n\n    longname: str = StringField(required=True, primary_key=True)\n    class_path: str = StringField(required=True)\n    label: str = StringField(required=True)\n    tooltip: str = StringField(required=True)\n\n    # NOTE: label and tooltip are there to be displayed in delegates\n\n    meta = {\n        'collection': 'Processes',\n        'db_alias': 'default',\n    }\n\n    def __repr__(self):\n        return f\"&lt;Process&gt;: {self.longname}\"\n\n    def __str__(self):\n        return self.__repr__()\n\n    @classmethod\n    def create(cls, longname: str, class_path: str, label: str, tooltip: str, **kwargs) -&gt; Self:\n        kwargs = dict(longname=longname, class_path=class_path, label=label, tooltip=tooltip, **kwargs)\n        kwargs = {k: v for k, v in kwargs.items() if v is not None}\n        process = cls(**kwargs)\n        process.save()\n        print(f\"Created: {process}\")\n        return process\n</code></pre>"},{"location":"reference/turbine/#job","title":"<code>Job</code>","text":"<p>An Engine's instance</p> Source code in <code>Breeze\\Api\\document_models\\project_documents.py</code> <pre><code>class Job(Document):\n    \"\"\" An Engine's instance \"\"\"\n    longname: str = StringField(required=True, primary_key=True) # name + date\n    user: User = ReferenceField(document_type=User, required=True)\n    creation_time = DateTimeField(default=datetime.now)\n    source_process: Process = ReferenceField(document_type=Process, required=True)\n    source_version: Version = ReferenceField(document_type=Version, required=True)\n    steps: dict[str, any] = DictField(required=True)\n    inputs: dict[str, Any] = DictField()  # dict[name: widget_infos]\n\n    meta = {\n        'collection': 'Jobs',\n        'db_alias': 'current_project',\n    }\n\n    def __repr__(self):\n        return f\"&lt;Job&gt;: {self.longname}\"\n\n    def __str__(self):\n        return self.__repr__()\n\n    @classmethod\n    def create(cls, source_process: Process, steps: dict[str, any], inputs: dict[str, any],\n               user: User, version: Version, creation_time: datetime,\n               **kwargs) -&gt; Self:\n        longname = \" \".join(s for s in [source_process.longname, version.longname, user.pseudo, str(creation_time)])\n        kwargs = dict(longname=longname, creation_time=creation_time, user=user,\n                      source_process=source_process, source_version=version,\n                      steps=steps, inputs=inputs, **kwargs)\n        kwargs = {k: v for k, v in kwargs.items() if v is not None}\n\n        process = cls(**kwargs)\n        process.save()\n        print(f\"Created: {process}\")\n\n        return process\n</code></pre>"},{"location":"reference/turbine/#diagram","title":"Diagram","text":"<pre><code>classDiagram\n    direction BT\n\n    TurbineStep --|&gt; TurbineEngine\n    TurbineGui --o TurbineEngine\n    TurbineGui --&gt; TurbineInputs\n    TurbineEngine &lt;..&gt; Process\n\n    TurbineEngine --&gt; Job\n    TurbineInputs --&gt; Job\n    JobContext --&gt; Job\n\n    class TurbineGui{\n        context: Jobcontext\n        widgets: list[TurbineWidgetBase]\n\n        _init_ui()\n        _connect_signals()\n        _init_state()\n        inputs()\n    }\n\n    class TurbineInputs{\n        use_last_version: bool\n        version_number: int\n        dont_overwrite: bool\n        ...\n    }\n\n    class JobContext{\n        user: User\n        component: Component\n        version: Version\n        creation_time: datetime\n    }\n\n    class Job [\"Job (Document)\"] {\n        source_process: Process\n        steps: dict[str, any]\n        inputs: dict[str, Any]\n        user: User\n        creation_time: datetime\n        source_process: Process\n        source_version: Version\n    }\n\n\n    class Process [\"Process (Document)\"] {\n        class_path: str\n    }\n</code></pre>"}]}